import{_ as s,c as i,o as a,a2 as t}from"./chunks/framework.Bfq10Vlj.js";const n="/assets/weeder-components.excalidraw.VbrStQSr.png",E=JSON.parse('{"title":"Weeder","description":"","frontmatter":{"github_repo":"https://github.com/gardener/dependency-watchdog","github_subdir":"docs/concepts","params":{"github_branch":"master"},"path_base_for_github_subdir":{"from":"content/docs/other-components/dependency-watchdog/concepts/weeder.md","to":"weeder.md"},"title":"Weeder","prev":false,"next":false},"headers":[],"relativePath":"docs/other-components/dependency-watchdog/concepts/weeder/index.md","filePath":"docs/other-components/dependency-watchdog/concepts/weeder.md","lastUpdated":null}'),r={name:"docs/other-components/dependency-watchdog/concepts/weeder/index.md"};function o(l,e,h,p,d,c){return a(),i("div",null,e[0]||(e[0]=[t('<h1 id="weeder" tabindex="-1">Weeder <a class="header-anchor" href="#weeder" aria-label="Permalink to &quot;Weeder&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>Weeder watches for an update to service endpoints and on receiving such an event it will create a time-bound watch for all configured dependent pods that need to be actively recovered in case they have not yet recovered from <code>CrashLoopBackoff</code> state. In a nutshell it accelerates recovery of pods when an upstream service recovers.</p><p>An interference in automatic recovery for dependent pods is required because kubernetes pod restarts a container with an exponential backoff when the pod is in <code>CrashLoopBackOff</code> state. This backoff could become quite large if the service stays down for long. Presence of weeder would not let that happen as it&#39;ll restart the pod.</p><h2 id="prerequisites" tabindex="-1">Prerequisites <a class="header-anchor" href="#prerequisites" aria-label="Permalink to &quot;Prerequisites&quot;">​</a></h2><p>Before we understand how Weeder works, we need to be familiar with kubernetes <a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noreferrer">services &amp; endpoints</a>.</p><blockquote><p>NOTE: If a kubernetes service is created with selectors then kubernetes will create corresponding endpoint resource which will have the same name as that of the service. In weeder implementation service and endpoint name is used interchangeably.</p></blockquote><h2 id="config" tabindex="-1">Config <a class="header-anchor" href="#config" aria-label="Permalink to &quot;Config&quot;">​</a></h2><p>Weeder can be configured via command line arguments and a weeder configuration. See <a href="/docs/other-components/dependency-watchdog/deployment/configure/#weeder">configure weeder</a>.</p><h2 id="internals" tabindex="-1">Internals <a class="header-anchor" href="#internals" aria-label="Permalink to &quot;Internals&quot;">​</a></h2><p>Weeder keeps a watch on the events for the specified endpoints in the config. For every endpoints a list of <code>podSelectors</code> can be specified. It cretes a weeder object per endpoints resource when it receives a satisfactory <code>Create</code> or <code>Update</code> event. Then for every podSelector it creates a goroutine. This goroutine keeps a watch on the pods with labels as per the podSelector and kills any pod which turn into <code>CrashLoopBackOff</code>. Each weeder lives for <code>watchDuration</code> interval which has a default value of 5 mins if not explicitly set.</p><p>To understand the actions taken by the weeder lets use the following diagram as a reference. <img src="'+n+`"> Let us also assume the following configuration for the weeder:</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">watchDuration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">2m0s</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">servicesAndDependantSelectors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  etcd-main-client</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># name of the service/endpoint for etcd statefulset that weeder will receive events for.</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    podSelectors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># all pods matching the label selector are direct dependencies for etcd service</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">matchExpressions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">gardener.cloud/role</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">            operator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">In</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">            values</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">controlplane</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">role</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">            operator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">In</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">            values</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">apiserver</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  kube-apiserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># name of the service/endpoint for kube-api-server pods that weeder will receive events for. </span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    podSelectors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># all pods matching the label selector are direct dependencies for kube-api-server service</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">matchExpressions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">gardener.cloud/role</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">            operator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">In</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">            values</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">controlplane</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">role</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">            operator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">NotIn</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">            values</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">main</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">apiserver</span></span></code></pre></div><p>Only for the sake of demonstration lets pick the first service -&gt; dependent pods tuple (<code>etcd-main-client</code> as the service endpoint).</p><blockquote><ol><li>Assume that there are 3 replicas for etcd statefulset.</li><li>Time here is just for showing the series of events</li></ol></blockquote><ul><li><code>t=0</code> -&gt; all etcd pods go down</li><li><code>t=10</code> -&gt; kube-api-server pods transition to CrashLoopBackOff</li><li><code>t=100</code> -&gt; all etcd pods recover together</li><li><code>t=101</code> -&gt; Weeder sees <code>Update</code> event for <code>etcd-main-client</code> endpoints resource</li><li><code>t=102</code> -&gt; go routine created to keep watch on kube-api-server pods</li><li><code>t=103</code> -&gt; Since kube-api-server pods are still in CrashLoopBackOff, weeder deletes the pods to accelerate the recovery.</li><li><code>t=104</code> -&gt; new kube-api-server pod created by replica-set controller in kube-controller-manager</li></ul><h3 id="points-to-note" tabindex="-1">Points to Note <a class="header-anchor" href="#points-to-note" aria-label="Permalink to &quot;Points to Note&quot;">​</a></h3><ul><li>Weeder only respond on <code>Update</code> events where a <code>notReady</code> endpoints resource turn to <code>Ready</code>. Thats why there was no weeder action at time <code>t=10</code> in the example above. <ul><li><code>notReady</code> -&gt; no backing pod is Ready</li><li><code>Ready</code> -&gt; atleast one backing pod is Ready</li></ul></li><li>Weeder doesn&#39;t respond on <code>Delete</code> events</li><li>Weeder will always wait for the entire <code>watchDuration</code>. If the dependent pods transition to CrashLoopBackOff after the watch duration or even after repeated deletion of these pods they do not recover then weeder will exit. Quality of service offered via a weeder is only Best-Effort.</li></ul>`,18)]))}const g=s(r,[["render",o]]);export{E as __pageData,g as default};
