import{_ as t,c as n,o as a,a2 as i}from"./chunks/framework.Bfq10Vlj.js";const g=JSON.parse('{"title":"Outline","description":"","frontmatter":{"github_repo":"https://github.com/gardener/machine-controller-manager","github_subdir":"docs/todo","params":{"github_branch":"master"},"path_base_for_github_subdir":{"from":"content/docs/other-components/machine-controller-manager/todo/outline.md","to":"outline.md"},"title":"Outline","prev":false,"next":false},"headers":[],"relativePath":"docs/other-components/machine-controller-manager/todo/outline/index.md","filePath":"docs/other-components/machine-controller-manager/todo/outline.md","lastUpdated":null}'),s={name:"docs/other-components/machine-controller-manager/todo/outline/index.md"};function o(r,e,d,l,c,h){return a(),n("div",null,e[0]||(e[0]=[i(`<h1 id="machine-controller-manager" tabindex="-1">Machine Controller Manager <a class="header-anchor" href="#machine-controller-manager" aria-label="Permalink to &quot;Machine Controller Manager&quot;">​</a></h1><p>CORE -- ./machine-controller-manager(provider independent) Out of tree : Machine controller (provider specific) MCM is a set controllers:</p><ul><li><p>Machine Deployment Controller</p></li><li><p>Machine Set Controller</p></li><li><p>Machine Controller</p></li><li><p>Machine Safety Controller</p></li></ul><h2 id="questions-and-refactoring-suggestions" tabindex="-1">Questions and refactoring Suggestions <a class="header-anchor" href="#questions-and-refactoring-suggestions" aria-label="Permalink to &quot;Questions and refactoring Suggestions&quot;">​</a></h2><h3 id="refactoring" tabindex="-1">Refactoring <a class="header-anchor" href="#refactoring" aria-label="Permalink to &quot;Refactoring&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Statement</th><th>FilePath</th><th>Status</th></tr></thead><tbody><tr><td>ConcurrentNodeSyncs” bad name - nothing to do with node syncs actually. <br> If its value is ’10’ then it will start 10 goroutines (workers) per resource type (machine, machinist, machinedeployment, provider-specific-class, node - study the different resource types.</td><td>cmd/machine-controller-manager/app/options/options.go</td><td>pending</td></tr><tr><td>LeaderElectionConfiguration is very similar to the one present in “client-go/tools/leaderelection/leaderelection.go” - can we simply used the one in client-go instead of defining again?</td><td>pkg/options/types.go - MachineControllerManagerConfiguration</td><td>pending</td></tr><tr><td>Have all userAgents as constant. Right now there is just one.</td><td>cmd/app/controllermanager.go</td><td>pending</td></tr><tr><td>Shouldn’t run function be defined on MCMServer struct itself?</td><td>cmd/app/controllermanager.go</td><td>pending</td></tr><tr><td>clientcmd.BuildConfigFromFlags fallsback to inClusterConfig which will surely not work as that is not the target. Should it not check and exit early?</td><td>cmd/app/controllermanager.go - run Function</td><td>pending</td></tr><tr><td>A more direct way to create an in cluster config is using <code>k8s.io/client-go/rest</code> -&gt; rest.InClusterConfig instead of using clientcmd.BuildConfigFromFlags passing empty arguments and depending upon the implementation to fallback to creating a inClusterConfig. If they change the implementation that you get affected.</td><td>cmd/app/controllermanager.go - run Function</td><td>pending</td></tr><tr><td>Introduce a method on MCMServer which gets a target KubeConfig and controlKubeConfig or alternatively which creates respective clients.</td><td>cmd/app/controllermanager.go - run Function</td><td>pending</td></tr><tr><td>Why can’t we use Kubernetes.NewConfigOrDie also for kubeClientControl?</td><td>cmd/app/controllermanager.go - run Function</td><td>pending</td></tr><tr><td>I do not see any benefit of client builders actually. All you need to do is pass in a config and then directly use client-go functions to create a client.</td><td>cmd/app/controllermanager.go - run Function</td><td>pending</td></tr><tr><td>Function: getAvailableResources - rename this to getApiServerResources</td><td>cmd/app/controllermanager.go</td><td>pending</td></tr><tr><td>Move the method which waits for API server to up and ready to a separate method which returns a discoveryClient when the API server is ready.</td><td>cmd/app/controllermanager.go - getAvailableResources function</td><td>pending</td></tr><tr><td>Many methods in client-go used are now deprecated. Switch to the ones that are now recommended to be used instead.</td><td>cmd/app/controllermanager.go - startControllers</td><td>pending</td></tr><tr><td>This method needs a general overhaul</td><td>cmd/app/controllermanager.go - startControllers</td><td>pending</td></tr><tr><td>If the design is influenced/copied from KCM then its very different. There are different controller structs defined for deployment, replicaset etc which makes the code much more clearer. You can see “kubernetes/cmd/kube-controller-manager/apps.go” and then follow the trail from there. - agreed needs to be changed in future (if time permits)</td><td>pkg/controller/controller.go</td><td>pending</td></tr><tr><td>I am not sure why “MachineSetControlInterface”, “RevisionControlInterface”, “MachineControlInterface”, “FakeMachineControl” are defined in this file?</td><td>pkg/controller/controller_util.go</td><td>pending</td></tr><tr><td><code>IsMachineActive</code> - combine the first 2 conditions into one with OR.</td><td>pkg/controller/controller_util.go</td><td>pending</td></tr><tr><td>Minor change - correct the comment, first word should always be the method name. Currently none of the comments have correct names.</td><td>pkg/controller/controller_util.go</td><td>pending</td></tr><tr><td>There are too many deep copies made. What is the need to make another deep copy in this method? You are not really changing anything here.</td><td>pkg/controller/deployment.go - updateMachineDeploymentFinalizers</td><td>pending</td></tr><tr><td>Why can&#39;t these validations be done as part of a validating webhook?</td><td>pkg/controller/machineset.go - reconcileClusterMachineSet</td><td>pending</td></tr><tr><td>Small change to the following <code>if</code> condition. <code>else if</code> is not required a simple <code>else</code> is sufficient. <a href="/docs/other-components/machine-controller-manager/todo/outline/#1.1-code1">Code1</a></td><td></td><td></td></tr><tr><td>pkg/controller/machineset.go - reconcileClusterMachineSet</td><td>pending</td><td></td></tr><tr><td>Why call these <code>inactiveMachines</code>, these are live and running and therefore active.</td><td>pkg/controller/machineset.go - terminateMachines</td><td>pending</td></tr></tbody></table><h3 id="clarification" tabindex="-1">Clarification <a class="header-anchor" href="#clarification" aria-label="Permalink to &quot;Clarification&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Statement</th><th>FilePath</th><th>Status</th></tr></thead><tbody><tr><td>Why are there 2 versions - internal and external versions?</td><td>General</td><td>pending</td></tr><tr><td>Safety controller freezes MCM controllers in the following cases: <br> * Num replicas go beyond a threshold (above the defined replicas) <br> * Target API service is not reachable <br> There seems to be an overlap between DWD and MCM Safety controller. In the meltdown scenario why is MCM being added to DWD, you could have used Safety controller for that.</td><td>General</td><td>pending</td></tr><tr><td>All machine resources are v1alpha1 - should we not promote it to beta. V1alpha1 has a different semantic and does not give any confidence to the consumers.</td><td>cmd/app/controllermanager.go</td><td>pending</td></tr><tr><td>Shouldn’t controller manager use context.Context instead of creating a stop channel? - Check if signals (<code>os.Interrupt</code> and <code>SIGTERM</code> are handled properly. Do not see code where this is handled currently.)</td><td>cmd/app/controllermanager.go</td><td>pending</td></tr><tr><td>What is the rationale behind a timeout of 10s? If the API server is not up, should this not just block as it can anyways not do anything. Also, if there is an error returned then you exit the MCM which does not make much sense actually as it will be started again and you will again do the poll for the API server to come back up. Forcing an exit of MCM will not have any impact on the reachability of the API server in anyway so why exit?</td><td>cmd/app/controllermanager.go - getAvailableResources</td><td>pending</td></tr><tr><td>There is a very weird check - <code> availableResources[machineGVR] || availableResources[machineSetGVR] || availableResources[machineDeploymentGVR] </code> <br> Shouldn’t this be conjunction instead of disjunction? <br>* What happens if you do not find one or all of these resources? <br> Currently an error log is printed and nothing else is done. MCM can be used outside gardener context where consumers can directly create MachineClass and Machine and not create MachineSet / Maching Deployment. There is no distinction made between context (gardener or outside-gardener). <br></td><td>cmd/app/controllermanager.go - StartControllers</td><td>pending</td></tr><tr><td>Instead of having an empty select {} to block forever, isn’t it better to wait on the stop channel?</td><td>cmd/app/controllermanager.go - StartControllers</td><td>pending</td></tr><tr><td>Do we need provider specific queues and syncs and listers</td><td>pkg/controller/controller.go</td><td>pending</td></tr><tr><td>Why are resource types prefixed with “Cluster”? - not sure , check PR</td><td>pkg/controller/controller.go</td><td>pending</td></tr><tr><td>When will forgetAfterSuccess be false and why? - as per the current code this is never the case. - Himanshu will check</td><td>cmd/app/controllermanager.go - createWorker</td><td>pending</td></tr><tr><td>What is the use of “ExpectationsInterface” and “UIDTrackingContExpectations”? <br>* All expectations related code should be in its own file “expectations.go” and not in this file.</td><td>pkg/controller/controller_util.go</td><td>pending</td></tr><tr><td>Why do we not use lister but directly use the controlMachingClient to get the deployment? Is it because you want to avoid any potential delays caused by update of the local cache held by the informer and accessed by the lister? What is the load on API server due to this?</td><td>pkg/controller/deployment.go - reconcileClusterMachineDeployment</td><td>pending</td></tr><tr><td>Why is this conversion needed? <a href="/docs/other-components/machine-controller-manager/todo/outline/#1.2-code2">code2</a></td><td>pkg/controller/deployment.go - reconcileClusterMachineDeployment</td><td>pending</td></tr><tr><td>A deep copy of <code>machineDeployment</code> is already passed and within the function another deepCopy is made. Any reason for it?</td><td>pkg/controller/deployment.go - addMachineDeploymentFinalizers</td><td>pending</td></tr><tr><td>What is an <code>Status.ObservedGeneration</code>? <br> *<em>Read more about generations and observedGeneration at: <br> <a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata" target="_blank" rel="noreferrer">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata</a> <br></em> <a href="https://alenkacz.medium.com/kubernetes-operator-best-practices-implementing-observedgeneration-250728868792" target="_blank" rel="noreferrer">https://alenkacz.medium.com/kubernetes-operator-best-practices-implementing-observedgeneration-250728868792</a> <br> Ideally the update to the <code>ObservedGeneration</code> should only be made after successful reconciliation and not before. I see that this is just copied from <code>deployment_controller.go</code> as is</td><td>pkg/controller/deployment.go - reconcileClusterMachineDeployment</td><td>pending</td></tr><tr><td>Why and when will a <code>MachineDeployment</code> be marked as frozen and when will it be un-frozen?</td><td>pkg/controller/deployment.go - reconcileClusterMachineDeployment</td><td>pending</td></tr><tr><td>Shoudn&#39;t the validation of the machine deployment be done during the creation via a validating webhook instead of allowing it to be stored in etcd and then failing the validation during sync? I saw the checks and these can be done via validation webhook.</td><td>pkg/controller/deployment.go - reconcileClusterMachineDeployment</td><td>pending</td></tr><tr><td>RollbackTo has been marked as deprecated. What is the replacement? <a href="/docs/other-components/machine-controller-manager/todo/outline/#1.3-code3">code3</a></td><td>pkg/controller/deployment.go - reconcileClusterMachineDeployment</td><td>pending</td></tr><tr><td>What is the max machineSet deletions that you could process in a single run? The reason for asking this question is that for every machineSetDeletion a new goroutine spawned. <br>* Is the <code>Delete</code> call a synchrounous call? Which means it blocks till the machineset deletion is triggered which then also deletes the machines (due to cascade-delete and blockOwnerDeletion= true)?</td><td>pkg/controller/deployment.go - terminateMachineSets</td><td>pending</td></tr><tr><td>If there are validation errors or error when creating label selector then a nil is returned. In the worker reconcile loop if the return value is nil then it will remove it from the queue (forget + done). What is the way to see any errors? Typically when we describe a resource the errors are displayed. Will these be displayed when we discribe a <code>MachineDeployment</code>?</td><td>pkg/controller/deployment.go - reconcileClusterMachineSet</td><td>pending</td></tr><tr><td>If an error is returned by <code>updateMachineSetStatus</code> and it is <code>IsNotFound</code> error then returning an error will again queue the <code>MachineSet</code>. Is this desired as <code>IsNotFound</code> indicates the <code>MachineSet</code> has been deleted and is no longer there?</td><td>pkg/controller/deployment.go - reconcileClusterMachineSet</td><td>pending</td></tr><tr><td>is <code>machineControl.DeleteMachine</code> a synchronous operation which will wait till the machine has been deleted? Also where is the <code>DeletionTimestamp</code> set on the <code>Machine</code>? Will it be automatically done by the API server?</td><td>pkg/controller/deployment.go - prepareMachineForDeletion</td><td>pending</td></tr></tbody></table><h3 id="bugs-enhancements" tabindex="-1">Bugs/Enhancements <a class="header-anchor" href="#bugs-enhancements" aria-label="Permalink to &quot;Bugs/Enhancements&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Statement + TODO</th><th>FilePath</th><th>Status</th></tr></thead><tbody><tr><td>This defines QPS and Burst for its requests to the KAPI. Check if it would make sense to explicitly define a FlowSchema and PriorityLevelConfiguration to ensure that the requests from this controller are given a well-defined preference. What is the rational behind deciding these values?</td><td>pkg/options/types.go - MachineControllerManagerConfiguration</td><td>pending</td></tr><tr><td>In function “validateMachineSpec” fldPath func parameter is never used.</td><td>pkg/apis/machine/validation/machine.go</td><td>pending</td></tr><tr><td>If there is an update failure then this method recursively calls itself without any sort of delays which could lead to a LOT of load on the API server. (opened: <a href="https://github.com/gardener/machine-controller-manager/issues/686" target="_blank" rel="noreferrer">https://github.com/gardener/machine-controller-manager/issues/686</a>)</td><td>pkg/controller/deployment.go - updateMachineDeploymentFinalizers</td><td>pending</td></tr><tr><td>We are updating <code>filteredMachines</code> by invoking <code>syncMachinesNodeTemplates</code>, <code>syncMachinesConfig</code> and <code>syncMachinesClassKind</code> but we do not create any deepCopy here. Everywhere else the general principle is when you mutate always make a deepCopy and then mutate the copy instead of the original as a lister is used and that changes the cached copy. <br> <code>Fix</code>: <code>SatisfiedExpectations</code> check has been commented and there is a TODO there to fix it. Is there a PR for this?</td><td>pkg/controller/machineset.go - reconcileClusterMachineSet</td><td>pending</td></tr></tbody></table><p>Code references</p><h1 id="_1-1-code1" tabindex="-1">1.1 code1 <a class="header-anchor" href="#_1-1-code1" aria-label="Permalink to &quot;1.1 code1&quot;">​</a></h1><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> machineSet.DeletionTimestamp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        		// manageReplicas is the core machineSet method where scale up/down occurs</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        		// It is not called when deletion timestamp is set</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        		manageReplicasErr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">manageReplicas</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, filteredMachines, machineSet)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        	} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> machineSet.DeletionTimestamp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //FIX: change this to simple else without the if</span></span></code></pre></div><h1 id="_1-2-code2" tabindex="-1">1.2 code2 <a class="header-anchor" href="#_1-2-code2" aria-label="Permalink to &quot;1.2 code2&quot;">​</a></h1><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dc.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">enqueueMachineDeploymentAfter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(deployment, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">time.Minute)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    *</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  \`Clarification\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:  Why  is  this  conversion  needed?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v1alpha1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Convert_v1alpha1_MachineDeployment_To_machine_MachineDeployment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(deployment, internalMachineDeployment, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h1 id="_1-3-code3" tabindex="-1">1.3 code3 <a class="header-anchor" href="#_1-3-code3" aria-label="Permalink to &quot;1.3 code3&quot;">​</a></h1><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// rollback is not re-entrant in case the underlying machine sets are updated with a new</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// revision so we should ensure that we won&#39;t proceed to update machine sets until we</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// make sure that the deployment has cleaned up its rollback spec in subsequent enqueues.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d.Spec.RollbackTo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dc.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rollback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, d, machineSets, machineMap)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span></code></pre></div>`,17)]))}const u=t(s,[["render",o]]);export{g as __pageData,u as default};
