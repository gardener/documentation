import{_ as a,c as i,o as n,a2 as s}from"./chunks/framework.Bfq10Vlj.js";const t="/assets/initialize-machine-triggercreationflow.jQdmRn-h.svg",k=JSON.parse('{"title":"Initialize Machine","description":"","frontmatter":{"github_repo":"https://github.com/gardener/machine-controller-manager","github_subdir":"docs/proposals","params":{"github_branch":"master"},"path_base_for_github_subdir":{"from":"content/docs/other-components/machine-controller-manager/proposals/initialize-machine.md","to":"initialize-machine.md"},"title":"Initialize Machine","prev":false,"next":false},"headers":[],"relativePath":"docs/other-components/machine-controller-manager/proposals/initialize-machine/index.md","filePath":"docs/other-components/machine-controller-manager/proposals/initialize-machine.md","lastUpdated":null}'),o={name:"docs/other-components/machine-controller-manager/proposals/initialize-machine/index.md"};function r(l,e,c,h,d,p){return n(),i("div",null,e[0]||(e[0]=[s(`<h1 id="post-create-initialization-of-machine-instance" tabindex="-1">Post-Create Initialization of Machine Instance <a class="header-anchor" href="#post-create-initialization-of-machine-instance" aria-label="Permalink to &quot;Post-Create Initialization of Machine Instance&quot;">​</a></h1><h2 id="background" tabindex="-1">Background <a class="header-anchor" href="#background" aria-label="Permalink to &quot;Background&quot;">​</a></h2><p>Today the <a href="https://github.com/gardener/machine-controller-manager/blob/rel-v0.49/pkg/util/provider/driver/driver.go#L28" target="_blank" rel="noreferrer">driver.Driver</a> facade represents the boundary between the the <code>machine-controller</code> and its various provider specific implementations.</p><p>We have abstract operations for creation/deletion and listing of machines (actually compute instances) but we do not correctly handle post-creation initialization logic. Nor do we provide an abstract operation to represent the hot update of an instance after creation.</p><p>We have found this to be necessary for several use cases. Today in the MCM AWS Provider, we already misuse <code>driver.GetMachineStatus</code> which is supposed to be a read-only operation obtaining the status of an instance.</p><ol><li><p>Each AWS EC2 instance performs source/destination checks by default. For <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_NAT_Instance.html#EIP_Disable_SrcDestCheck" target="_blank" rel="noreferrer">EC2 NAT</a> instances these should be disabled. This is done by issuing a <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html" target="_blank" rel="noreferrer">ModifyInstanceAttribute</a> request with the <code>SourceDestCheck</code> set to <code>false</code>. The MCM AWS Provider, decodes the <a href="https://github.com/gardener/machine-controller-manager-provider-aws/blob/39318bb2b5b4a573fdc77eaf400839d12c4abf59/pkg/aws/apis/aws_provider_spec.go#L63" target="_blank" rel="noreferrer">AWSProviderSpec</a>, reads <code>providerSpec.SrcAndDstChecksEnabled</code> and correspondingly issues the call to modify the already launched instance. However, this should be done as an action after creating the instance and should not be part of the VM status retrieval.</p></li><li><p>Similarly, there is a <a href="https://github.com/gardener/machine-controller-manager-provider-aws/pull/128" target="_blank" rel="noreferrer">pending PR</a> to add the <code>Ipv6AddessCount</code> and <code>Ipv6PrefixCount</code> to enable the assignment of an ipv6 address and an ipv6 prefix to instances. This requires constructing and issuing an <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_AssignIpv6Addresses.html" target="_blank" rel="noreferrer">AssignIpv6Addresses</a> request after the EC2 instance is available.</p></li><li><p>We have other uses-cases such as <a href="https://github.com/gardener/machine-controller-manager/issues/750" target="_blank" rel="noreferrer">MCM Issue#750</a> where there is a requirement to provide a way for consumers to add tags which can be hot-updated onto instances. This requirement can be generalized to also offer a convenient way to specify tags which can be applied to VMs, NICs, Devices etc.</p></li><li><p>We have a need for &quot;machine-instance-not-ready&quot; taint as described in <a href="https://github.com/gardener/machine-controller-manager/issues/740" target="_blank" rel="noreferrer">MCM#740</a> which should only get removed once the post creation updates are finished.</p></li></ol><h2 id="objectives" tabindex="-1">Objectives <a class="header-anchor" href="#objectives" aria-label="Permalink to &quot;Objectives&quot;">​</a></h2><p>We will split the fulfilment of this overall need into 2 stages of implementation.</p><ol><li><p><strong>Stage-A</strong>: Support post-VM creation initialization logic of the instance suing a proposed <code>Driver.InitializeMachine</code> by permitting provider implementors to add initialization logic after VM creation, return with special new error code <code>codes.Initialization</code> for initialization errors and correspondingly support a new machine operation stage <code>InstanceInitialization</code> which will be updated in the machine <code>LastOperation</code>. The <a href="https://github.com/gardener/machine-controller-manager/blob/rel-v0.50/pkg/util/provider/machinecontroller/machine.go#L310" target="_blank" rel="noreferrer">triggerCreationFlow</a> - a reconciliation sub-flow of the MCM responsible for orchestrating instance creation and updating machine status will be changed to support this behaviour.</p></li><li><p><strong>Stage-B</strong>: Introduction of <code>Driver.UpdateMachine</code> and enhancing the MCM, MCM providers and gardener extension providers to support hot update of instances through <code>Driver.UpdateMachine</code>. The MCM <a href="https://github.com/gardener/machine-controller-manager/blob/v0.50.1/pkg/util/provider/machinecontroller/machine.go#L531" target="_blank" rel="noreferrer">triggerUpdationFlow</a> - a reconciliation sub-flow of the MCM which is supposed to be responsible for orchestrating instance update - but currently not used, will be updated to invoke the provider <code>Driver.UpdateMachine</code> on hot-updates to to the <code>Machine</code> object</p></li></ol><h2 id="stage-a-proposal" tabindex="-1">Stage-A Proposal <a class="header-anchor" href="#stage-a-proposal" aria-label="Permalink to &quot;Stage-A Proposal&quot;">​</a></h2><h3 id="current-mcm-triggercreationflow" tabindex="-1">Current MCM triggerCreationFlow <a class="header-anchor" href="#current-mcm-triggercreationflow" aria-label="Permalink to &quot;Current MCM triggerCreationFlow&quot;">​</a></h3><p>Today, <a href="https://github.com/gardener/machine-controller-manager/blob/v0.50.1/pkg/util/provider/machinecontroller/machine.go#L89" target="_blank" rel="noreferrer">reconcileClusterMachine</a> which is the main routine for the <code>Machine</code> object reconciliation invokes <a href="https://github.com/gardener/machine-controller-manager/blob/rel-v0.50/pkg/util/provider/machinecontroller/machine.go#L310" target="_blank" rel="noreferrer">triggerCreationFlow</a> at the end when the <code>machine.Spec.ProviderID</code> is empty or if the <code>machine.Status.CurrentStatus.Phase</code> is empty or in <code>CrashLoopBackOff</code></p><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">%%{ init: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &#39;themeVariables&#39;:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        { &#39;fontSize&#39;: &#39;12px&#39;}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} }%%</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flowchart LR</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">other[&quot;...&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--&gt;chk{&quot;machine ProviderID empty</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">OR</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Phase empty or CrashLoopBackOff ?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&quot;}--yes--&gt;triggerCreationFlow</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">chk--noo--&gt;LongRetry[&quot;return machineutils.LongRetry&quot;]</span></span></code></pre></div><p>Today, the <code>triggerCreationFlow</code> is illustrated below with some minor details omitted/compressed for brevity</p><p><em>NOTES</em></p><ul><li>The <code>lastop</code> below is an abbreviation for <code>machine.Status.LastOperation</code>. This, along with the machine phase is generally updated on the <code>Machine</code> object just before returning from the method.</li><li>regarding <code>phase=CrashLoopBackOff|Failed</code>. the machine phase may either be <code>CrashLoopBackOff</code> or move to <code>Failed</code> if the difference between current time and the <code>machine.CreationTimestamp</code> has exceeded the configured <code>MachineCreationTimeout</code>.</li></ul><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">%%{ init: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &#39;themeVariables&#39;:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        { &#39;fontSize&#39;: &#39;12px&#39;}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} }%%</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flowchart TD</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">end1((&quot;end&quot;))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">begin((&quot; &quot;))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">medretry[&quot;return MediumRetry, err&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">shortretry[&quot;return ShortRetry, err&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">medretry--&gt;end1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">shortretry--&gt;end1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">begin--&gt;AddBootstrapTokenToUserData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--&gt;gms[&quot;statusResp,statusErr=driver.GetMachineStatus(...)&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--&gt;chkstatuserr{&quot;Check statusErr&quot;}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">chkstatuserr--notFound--&gt;chknodelbl{&quot;Chk Node Label&quot;}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">chkstatuserr--else--&gt;createFailed[&quot;lastop.Type=Create,lastop.state=Failed,phase=CrashLoopBackOff|Failed&quot;]--&gt;medretry</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">chkstatuserr--nil--&gt;initnodename[&quot;nodeName = statusResp.NodeName&quot;]--&gt;setnodename</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">chknodelbl--notset--&gt;createmachine[&quot;createResp, createErr=driver.CreateMachine(...)&quot;]--&gt;chkCreateErr{&quot;Check createErr&quot;}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">chkCreateErr--notnil--&gt;createFailed</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">chkCreateErr--nil--&gt;getnodename[&quot;nodeName = createResp.NodeName&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--&gt;chkstalenode{&quot;nodeName != machine.Name\\n//chk stale node&quot;}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">chkstalenode--false--&gt;setnodename[&quot;if unset machine.Labels[&#39;node&#39;]= nodeName&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--&gt;machinepending[&quot;if empty/crashloopbackoff lastop.type=Create,lastop.State=Processing,phase=Pending&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--&gt;shortretry</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">chkstalenode--true--&gt;delmachine[&quot;driver.DeleteMachine(...)&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--&gt;permafail[&quot;lastop.type=Create,lastop.state=Failed,Phase=Failed&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--&gt;shortretry</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">subgraph noteA [&quot; &quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    permafail -.- note1([&quot;VM was referring to stale node obj&quot;])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">end</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">style noteA opacity:0</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">subgraph noteB [&quot; &quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    setnodename-.- note2([&quot;Proposal: Introduce Driver.InitializeMachine after this&quot;])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">end</span></span></code></pre></div><h3 id="enhancement-of-mcm-triggercreationflow" tabindex="-1">Enhancement of MCM triggerCreationFlow <a class="header-anchor" href="#enhancement-of-mcm-triggercreationflow" aria-label="Permalink to &quot;Enhancement of MCM triggerCreationFlow&quot;">​</a></h3><h4 id="relevant-observations-on-current-flow" tabindex="-1">Relevant Observations on Current Flow <a class="header-anchor" href="#relevant-observations-on-current-flow" aria-label="Permalink to &quot;Relevant Observations on Current Flow&quot;">​</a></h4><ol><li>Observe that we always perform a call to <code>Driver.GetMachineStatus</code> and only then conditionally perform a call to <code>Driver.CreateMachine</code> if there was was no machine found.</li><li>Observe that after the call to a successful <code>Driver.CreateMachine</code>, the machine phase is set to <code>Pending</code>, the <code>LastOperation.Type</code> is currently set to <code>Create</code> and the <code>LastOperation.State</code> set to <code>Processing</code> before returning with a <code>ShortRetry</code>. The <code>LastOperation.Description</code> is (unfortunately) set to the fixed message: <code>Creating machine on cloud provider</code>.</li><li>Observe that after an erroneous call to <code>Driver.CreateMachine</code>, the machine phase is set to <code>CrashLoopBackOff</code> or <code>Failed</code> (in case of creation timeout).</li></ol><p>The following changes are proposed with a view towards minimal impact on current code and no introduction of a new Machine Phase.</p><h4 id="mcm-changes" tabindex="-1">MCM Changes <a class="header-anchor" href="#mcm-changes" aria-label="Permalink to &quot;MCM Changes&quot;">​</a></h4><ol><li>We propose introducing a new machine operation <code>Driver.InitializeMachine</code> with the following signature<div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Driver</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // .. existing methods are omitted for brevity.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // InitializeMachine call is responsible for post-create initialization of the provider instance.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    InitializeMachine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">InitializeMachineRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">error</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// InitializeMachineRequest is the initialization request for machine instance initialization</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> InitializeMachineRequest</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Machine object whose VM instance should be initialized </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Machine </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">v1alpha1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Machine</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // MachineClass backing the machine object</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    MachineClass </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">v1alpha1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MachineClass</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Secret backing the machineClass object</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Secret </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">corev1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Secret</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li>We propose introducing a new MC error code <code>codes.Initialization</code> indicating that the VM Instance was created but there was an error in initialization after VM creation. The implementor of <code>Driver.InitializeMachine</code> can return this error code, indicating that <code>InitializeMachine</code> needs to be called again. The Machine Controller will change the phase to <code>CrashLoopBackOff</code> as usual when encountering a <code>codes.Initialization</code> error.</li><li>We will introduce a new <em>machine operation</em> stage <code>InstanceInitialization</code>. In case of an <code>codes.Initialization</code> error <ol><li>the <code>machine.Status.LastOperation.Description</code> will be set to <code>InstanceInitialization</code>,</li><li><code>machine.Status.LastOperation.ErrorCode</code> will be set to <code>codes.Initialization</code></li><li>the <code>LastOperation.Type</code> will be set to <code>Create</code></li><li>the <code>LastOperation.State</code> set to <code>Failed</code> before returning with a <code>ShortRetry</code></li></ol></li><li>The semantics of <code>Driver.GetMachineStatus</code> will be changed. If the instance associated with machine exists, but the instance was not initialized as expected, the provider implementations of <code>GetMachineStatus</code> should return an error: <code>status.Error(codes.Initialization)</code>.</li><li>If <code>Driver.GetMachineStatus</code> returned an error encapsulating <code>codes.Initialization</code> then <code>Driver.InitializeMachine</code> will be invoked again in the <code>triggerCreationFlow</code>.</li><li>As according to the usual logic, the main machine controller reconciliation loop will now re-invoke the <code>triggerCreationFlow</code> again if the machine phase is <code>CrashLoopBackOff</code>.</li></ol><h4 id="illustration" tabindex="-1">Illustration <a class="header-anchor" href="#illustration" aria-label="Permalink to &quot;Illustration&quot;">​</a></h4><p><img src="`+t+'" alt="Enhanced triggerCreationFlow"></p><h4 id="aws-provider-changes" tabindex="-1">AWS Provider Changes <a class="header-anchor" href="#aws-provider-changes" aria-label="Permalink to &quot;AWS Provider Changes&quot;">​</a></h4><h5 id="driver-initializemachine" tabindex="-1">Driver.InitializeMachine <a class="header-anchor" href="#driver-initializemachine" aria-label="Permalink to &quot;Driver.InitializeMachine&quot;">​</a></h5><p>The implementation for the AWS Provider will look something like:</p><ol><li>After the VM instance is available, check <code>providerSpec.SrcAndDstChecksEnabled</code>, construct <code>ModifyInstanceAttributeInput</code> and call <code>ModifyInstanceAttribute</code>. In case of an error return <code>codes.Initialization</code> instead of the current <code>codes.Internal</code></li><li>Check <code>providerSpec.NetworkInterfaces</code> and if <code>Ipv6PrefixCount</code> is not <code>nil</code>, then construct <code>AssignIpv6AddressesInput</code> and call <code>AssignIpv6Addresses</code>. In case of an error return <code>codes.Initialization</code>. Don&#39;t use the generic <code>codes.Internal</code></li></ol><p>The <a href="https://github.com/gardener/machine-controller-manager-provider-aws/pull/128" target="_blank" rel="noreferrer">existing Ipv6 PR</a> will need modifications.</p><h5 id="driver-getmachinestatus" tabindex="-1">Driver.GetMachineStatus <a class="header-anchor" href="#driver-getmachinestatus" aria-label="Permalink to &quot;Driver.GetMachineStatus&quot;">​</a></h5><ol><li>If <code>providerSpec.SrcAndDstChecksEnabled</code> is <code>false</code>, check <code>ec2.Instance.SourceDestCheck</code>. If it does not match then return <code>status.Error(codes.Initialization)</code></li><li>Check <code>providerSpec.NetworkInterfaces</code> and if <code>Ipv6PrefixCount</code> is not <code>nil</code>, check <code>ec2.Instance.NetworkInterfaces</code> and check if <code>InstanceNetworkInterface.Ipv6Addresses</code> has a non-nil slice. If this is not the case then return <code>status.Error(codes.Initialization)</code></li></ol><h3 id="instance-not-ready-taint" tabindex="-1">Instance Not Ready Taint <a class="header-anchor" href="#instance-not-ready-taint" aria-label="Permalink to &quot;Instance Not Ready Taint&quot;">​</a></h3><ul><li>Due to the fact that creation flow for machines will now be enhanced to correctly support post-creation startup logic, we should not scheduled workload until this startup logic is complete. Even without this feature we have a need for such a taint as described in <a href="https://github.com/gardener/machine-controller-manager/issues/740" target="_blank" rel="noreferrer">MCM#740</a></li><li>We propose a new taint <code>node.machine.sapcloud.io/instance-not-ready</code> which will be added as a node startup taint in gardener core <a href="https://github.com/gardener/gardener/blob/v1.83.1/pkg/component/extensions/operatingsystemconfig/original/components/kubelet/config.go#L101" target="_blank" rel="noreferrer">KubeletConfiguration.RegisterWithTaints</a></li><li>The will will then removed by MCM in health check reconciliation, once the machine becomes fully ready. (when moving to <code>Running</code> phase)</li><li>We will add this taint as part of <code>--ignore-taint</code> in CA</li><li>We will introduce a disclaimer / prerequisite in the MCM FAQ, to add this taint as part of kubelet config under <code>--register-with-taints</code>, otherwise workload could get scheduled , before machine beomes <code>Running</code></li></ul><h2 id="stage-b-proposal" tabindex="-1">Stage-B Proposal <a class="header-anchor" href="#stage-b-proposal" aria-label="Permalink to &quot;Stage-B Proposal&quot;">​</a></h2><h3 id="enhancement-of-driver-interface-for-hot-updation" tabindex="-1">Enhancement of Driver Interface for Hot Updation <a class="header-anchor" href="#enhancement-of-driver-interface-for-hot-updation" aria-label="Permalink to &quot;Enhancement of Driver Interface for Hot Updation&quot;">​</a></h3><p>Kindly refer to the <a href="/docs/other-components/machine-controller-manager/proposals/hotupdate-instances/">Hot-Update Instances</a> design which provides elaborate detail.</p>',37)]))}const u=a(o,[["render",r]]);export{k as __pageData,u as default};
