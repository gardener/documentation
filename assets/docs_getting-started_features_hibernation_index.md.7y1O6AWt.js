import{_ as t,c as a,o,a2 as n}from"./chunks/framework.Bfq10Vlj.js";const i="/assets/hibernation.BDuuZSpi.gif",r="/assets/trigger-hibernation.TNR1p4Az.png",g=JSON.parse('{"title":"Hibernation","description":"","frontmatter":{"github_repo":"https://github.com/gardener/documentation","github_subdir":"website/documentation/getting-started/features","params":{"github_branch":"master"},"path_base_for_github_subdir":{"from":"content/docs/getting-started/features/hibernation.md","to":"hibernation.md"},"title":"Hibernation","weight":1,"prev":false,"next":false},"headers":[],"relativePath":"docs/getting-started/features/hibernation/index.md","filePath":"docs/getting-started/features/hibernation.md","lastUpdated":null}'),s={name:"docs/getting-started/features/hibernation/index.md"};function l(d,e,h,c,u,p){return o(),a("div",null,e[0]||(e[0]=[n('<h1 id="hibernation" tabindex="-1">Hibernation <a class="header-anchor" href="#hibernation" aria-label="Permalink to &quot;Hibernation&quot;">​</a></h1><p>Some clusters need to be up all the time - typically, they would be hosting some kind of production workload. Others might be used for development purposes or testing during business hours only. Keeping them up and running all the time is a waste of money. Gardener can help you here with its &quot;hibernation&quot; feature. Essentially, hibernation means to shut down all components of a cluster.</p><h2 id="how-hibernation-works" tabindex="-1">How Hibernation Works <a class="header-anchor" href="#how-hibernation-works" aria-label="Permalink to &quot;How Hibernation Works&quot;">​</a></h2><p>The hibernation flow for a shoot attempts to reduce the resources consumed as much as possible. Hence everything not state-related is being decommissioned.</p><p><img src="'+i+'" alt="hibernation"></p><h3 id="data-plane" tabindex="-1">Data Plane <a class="header-anchor" href="#data-plane" aria-label="Permalink to &quot;Data Plane&quot;">​</a></h3><p>All nodes will be drained and the VMs will be deleted. As a result, all pods will be &quot;stuck&quot; in a <code>Pending</code> state since no new nodes are added. Of course, PVC / PV holding data is not deleted.</p><p>Services of type <code>LoadBalancer</code> will keep their external IP addresses.</p><h3 id="control-plane" tabindex="-1">Control Plane <a class="header-anchor" href="#control-plane" aria-label="Permalink to &quot;Control Plane&quot;">​</a></h3><p>All components will be scaled down and no pods will remain running. ETCD data is kept safe on the disk.</p><p>The DNS records routing traffic for the API server are also destroyed. Trying to connect to a hibernated cluster via kubectl will result in a DNS lookup failure / no-such-host message.</p><p>When waking up a cluster, all control plane components will be scaled up again and the DNS records will be re-created. Nodes will be created again and pods scheduled to run on them.</p><h2 id="how-to-configure-trigger-hibernation" tabindex="-1">How to Configure / Trigger Hibernation <a class="header-anchor" href="#how-to-configure-trigger-hibernation" aria-label="Permalink to &quot;How to Configure / Trigger Hibernation&quot;">​</a></h2><p>The easiest way to configure hibernation schedules is via the dashboard. Of course, this is reflected in the shoot&#39;s spec and can also be maintained there. Before a cluster is hibernated, constraints in the shoot&#39;s status will be evaluated. There might be conditions (mostly revolving around mutating / validating webhooks) that would block a successful wake-up. In such a case, the constraint will block hibernation in the first place.</p><p><img src="'+r+'" alt="trigger-hibernation"></p><p>To wake-up or hibernate a shoot immediately, the dashboard can be used or a patch to the shoot&#39;s spec can be applied directly.</p>',16)]))}const m=t(s,[["render",l]]);export{g as __pageData,m as default};
