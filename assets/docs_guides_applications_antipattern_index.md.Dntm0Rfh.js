import{_ as t,c as n,o,a2 as a,j as s}from"./chunks/framework.Bfq10Vlj.js";const r="/assets/blog-antipattern.BFFZsXA6.png",g=JSON.parse('{"title":"Kubernetes Antipatterns","description":"Common antipatterns for Kubernetes and Docker","frontmatter":{"category":"Getting Started","description":"Common antipatterns for Kubernetes and Docker","github_repo":"https://github.com/gardener/documentation","github_subdir":"website/documentation/guides/applications","last_reviewed":"12.06.2018","level":"beginner","params":{"github_branch":"master"},"path_base_for_github_subdir":{"from":"content/docs/guides/applications/antipattern.md","to":"antipattern.md"},"reviewer":"Tieyan Fu","scope":"app-developer","title":"Kubernetes Antipatterns","prev":false,"next":false},"headers":[],"relativePath":"docs/guides/applications/antipattern/index.md","filePath":"docs/guides/applications/antipattern.md","lastUpdated":null}'),i={name:"docs/guides/applications/antipattern/index.md"};function d(p,e,c,h,l,u){return o(),n("div",null,e[0]||(e[0]=[a('<h1 id="kubernetes-antipatterns" tabindex="-1">Kubernetes Antipatterns <a class="header-anchor" href="#kubernetes-antipatterns" aria-label="Permalink to &quot;Kubernetes Antipatterns&quot;">â€‹</a></h1><p><img src="'+r+'" alt="antipattern"></p><p>This HowTo covers common Kubernetes antipatterns that we have seen over the past months.</p><h2 id="running-as-root-user" tabindex="-1">Running as Root User <a class="header-anchor" href="#running-as-root-user" aria-label="Permalink to &quot;Running as Root User&quot;">â€‹</a></h2><p>Whenever possible, do not run containers as root user. One could be tempted to say that Kubernetes pods and nodes are well separated. Host and containers running on it share the same kernel. If a container is compromised, the root user in the container has full control over the underlying node.</p><p>Watch the very good presentation by Liz Rice at the KubeCon 2018</p>',6),s("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/ltrV-Qmh3oY",frameborder:"0",allow:"autoplay; encrypted-media",allowfullscreen:""},null,-1),a(`<p>Use <code>RUN groupadd -r anygroup &amp;&amp; useradd -r -g anygroup myuser</code> to create a group and add a user to it. Use the <code>USER</code> command to switch to this user. Note that you may also consider to provide <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#user" target="_blank" rel="noreferrer">an explicit UID/GID</a> if required.</p><p>For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ARG GF_UID=&quot;500&quot;</span></span>
<span class="line"><span>ARG GF_GID=&quot;500&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># add group &amp; user</span></span>
<span class="line"><span>RUN groupadd -r -g $GF_GID appgroup &amp;&amp; \\</span></span>
<span class="line"><span>   useradd appuser -r -u $GF_UID -g appgroup</span></span>
<span class="line"><span></span></span>
<span class="line"><span>USER appuser</span></span></code></pre></div><h2 id="store-data-or-logs-in-containers" tabindex="-1">Store Data or Logs in Containers <a class="header-anchor" href="#store-data-or-logs-in-containers" aria-label="Permalink to &quot;Store Data or Logs in Containers&quot;">â€‹</a></h2><p>Containers are ideal for stateless applications and should be transient. This means that no data or logs should be stored in the container, as they are lost when the container is closed. Use persistence volumes instead to persist data outside of containers. Using an <a href="https://www.elastic.co/de/what-is/elk-stack" target="_blank" rel="noreferrer">ELK stack</a> is another good option for storing and processing logs.</p><h2 id="using-pod-ip-addresses" tabindex="-1">Using Pod IP Addresses <a class="header-anchor" href="#using-pod-ip-addresses" aria-label="Permalink to &quot;Using Pod IP Addresses&quot;">â€‹</a></h2><p>Each pod is assigned an IP address. It is necessary for pods to communicate with each other to build an application, e.g. an application must communicate with a database. Existing pods are terminated and new pods are constantly started. If you would rely on the IP address of a pod or container, you would need to update the application configuration constantly. This makes the application fragile.</p><p>Create services instead. They provide a logical name that can be assigned independently of the varying number and IP addresses of containers. Services are the basic concept for load balancing within Kubernetes.</p><h2 id="more-than-one-process-in-a-container" tabindex="-1">More Than One Process in a Container <a class="header-anchor" href="#more-than-one-process-in-a-container" aria-label="Permalink to &quot;More Than One Process in a Container&quot;">â€‹</a></h2><p>A docker file provides a <code>CMD</code> and <code>ENTRYPOINT</code> to start the image. <code>CMD</code> is often used around a script that makes a configuration and then starts the container. Do not try to start multiple processes with this script. It is important to consider the separation of concerns when creating docker images. Running multiple processes in a single pod makes managing your containers, collecting logs and updating each process more difficult.</p><p>You can split the image into multiple containers and manage them independently - even in one pod. Bear in mind that Kubernetes only monitors the process with <code>PID=1</code>. If more than one process is started within a container, then these no longer fall under the control of Kubernetes.</p><h2 id="creating-images-in-a-running-container" tabindex="-1">Creating Images in a Running Container <a class="header-anchor" href="#creating-images-in-a-running-container" aria-label="Permalink to &quot;Creating Images in a Running Container&quot;">â€‹</a></h2><p>A new image can be created with the <code>docker commit</code> command. This is useful if changes have been made to the container and you want to persist them for later error analysis. However, images created like this are not reproducible and completely worthless for a CI/CD environment. Furthermore, another developer cannot recognize which components the image contains. Instead, always make changes to the docker file, close existing containers and start a new container with the updated image.</p><h2 id="saving-passwords-in-a-docker-image-ðŸ’€" tabindex="-1">Saving Passwords in a docker Image ðŸ’€ <a class="header-anchor" href="#saving-passwords-in-a-docker-image-ðŸ’€" aria-label="Permalink to &quot;Saving Passwords in a docker Image  ðŸ’€&quot;">â€‹</a></h2><p><strong>Do not save passwords in a Docker file!</strong> They are in plain text and are checked into a repository. That makes them completely vulnerable even if you are using a private repository like the Artifactory.</p><p>Always use <a href="https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure" target="_blank" rel="noreferrer">Secrets or ConfigMaps</a> to provision passwords or inject them by mounting a persistent volume.</p><h2 id="using-the-latest-tag" tabindex="-1">Using the &#39;latest&#39; Tag <a class="header-anchor" href="#using-the-latest-tag" aria-label="Permalink to &quot;Using the &#39;latest&#39; Tag&quot;">â€‹</a></h2><p>Starting an image with <em>tomcat</em> is tempting. If no tags are specified, a container is started with the <code>tomcat:latest</code> image. This image may no longer be up to date and refer to an older version instead. Running a production application requires complete control of the environment with exact versions of the image.</p><p>Make sure you always use a tag or even better the <strong>sha256 hash</strong> of the image, e.g., <code>tomcat@sha256:c34ce3c1fcc0c7431e1392cc3abd0dfe2192ffea1898d5250f199d3ac8d8720f</code>.</p><h3 id="why-use-the-sha256-hash" tabindex="-1">Why Use the sha256 Hash? <a class="header-anchor" href="#why-use-the-sha256-hash" aria-label="Permalink to &quot;Why Use the sha256 Hash?&quot;">â€‹</a></h3><p>Tags are not immutable and can be overwritten by a developer at any time. In this case you don&#39;t have complete control over your image - which is bad.</p><h2 id="different-images-per-environment" tabindex="-1">Different Images per Environment <a class="header-anchor" href="#different-images-per-environment" aria-label="Permalink to &quot;Different Images per Environment&quot;">â€‹</a></h2><p>Don&#39;t create different images for development, testing, staging and production environments. The image should be the <strong>source of truth</strong> and should only be created once and pushed to the repository. This <code>image:tag</code> should be used for different environments in the future.</p><h2 id="depend-on-start-order-of-pods" tabindex="-1">Depend on Start Order of Pods <a class="header-anchor" href="#depend-on-start-order-of-pods" aria-label="Permalink to &quot;Depend on Start Order of Pods&quot;">â€‹</a></h2><p>Applications often depend on containers being started in a certain order. For example, a database container must be up and running before an application can connect to it. The application should be resilient to such changes, as the db pod can be unreachable or restarted at any time. The application container should be able to handle such situations without terminating or crashing.</p><h2 id="additional-anti-patterns-and-patterns" tabindex="-1">Additional Anti-Patterns and Patterns <a class="header-anchor" href="#additional-anti-patterns-and-patterns" aria-label="Permalink to &quot;Additional Anti-Patterns and Patterns&quot;">â€‹</a></h2><p>In the community, vast experience has been collected to improve the stability and usability of Docker and Kubernetes.</p><p>Refer to <a href="https://github.com/gravitational/workshop/blob/master/k8sprod.md" target="_blank" rel="noreferrer">Kubernetes Production Patterns</a> for more information.</p>`,28)]))}const b=t(i,[["render",d]]);export{g as __pageData,b as default};
